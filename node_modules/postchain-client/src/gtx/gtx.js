
const util = require('../util');
const gtv = require("../gtv");

exports.emptyGtx = function (blockchainRID) {
    return {blockchainRID: blockchainRID, operations: [], signers: []};
};

/**
 * Adds a function call to a GTX. Creates a new GTX if none specified.
 * This function will throw Error if gtx is already signed
 * @param opName the name of the function to call
 * @param args the array of arguments of the function call. If no args, this must be an empty array
 * @param gtx the function call will be added to this gtx
 * @returns the gtx
 * @throws if gtx is null or if gtx is already signed
 */
exports.addTransactionToGtx = function (opName, args, gtx) {
    if (gtx == null) {
        throw new Error("No Gtx to add operation to")
    }
    if (gtx.signatures) {
        throw new Error("Cannot add function calls to an already signed gtx");
    }
    gtx.operations.push({opName: opName, args: args});
    return gtx;
}

exports.addSignerToGtx = function (signer, gtx) {
    if (gtx.signatures) {
        throw new Error("Cannot add signers to an already signed gtx");
    }
    gtx.signers.push(signer);
};

/**
 * Serializes the gtx for signing
 * @param gtx the gtx to serialize
 */
exports.getDigestToSign = function (gtx) {
    return gtv.gtvHash(gtvTxBody(gtx));
};

function gtvTxBody(txData) {
    return [
        txData.blockchainRID,
        txData.operations.map(
            (op) => [op.opName, op.args]
        ),
        txData.signers
    ];
}

/**
 * Signs the gtx with the provided privKey. This is a convenience function
 * for situations where you don't have to ask someone else to sign.
 */
exports.sign = function (privKey, pubKey, gtx) {
    var digestToSign = module.exports.getDigestToSign(gtx);
    var signature = util.signDigest(digestToSign, privKey);
    console.log("PubKey: " + pubKey.toString('hex'));
    console.log("Signature: " + signature.toString('hex'));
    module.exports.addSignature(pubKey, signature, gtx);
};

exports.signRawTransaction = function (keyPair, rawTransaction) {
    throw Error("TODO");
    //TODO
    const gtx = module.exports.deserialize(rawTransaction);
    module.exports.sign(keyPair.privKey, keyPair.pubKey, gtx);
    return module.exports.serialize(gtx)
};

/**
 * Adds a signature to the gtx
 */
exports.addSignature = function (pubKeyBuffer, signatureBuffer, gtx) {
    if (!gtx.signatures) {
        gtx.signatures = Array(gtx.signers.length).fill(Buffer.alloc(0));
    }
    if (gtx.signers.length !== gtx.signatures.length) {
        throw new Error("Mismatching signers and signatures");
    }
    var signerIndex = gtx.signers.findIndex((signer) => pubKeyBuffer.equals(signer));
    if (signerIndex === -1) {
        throw new Error("No such signer, remember to call addSignerToGtx() before adding a signature");
    }
    gtx.signatures[signerIndex] = signatureBuffer;
};

exports.serialize = function (gtx) {
    if (!gtx.signatures) {
        // TODO
        // The gtx is not signed, but we must include
        // the signatures attribute, so let's add that.
        gtx.signatures = [];
    }
    return gtv.encodeGtv([
        gtvTxBody(gtx),
        gtx.signatures
    ]);
};

exports.deserialize = function (gtxBytes) {
    const deserializedTx = gtv.decodeGtv(gtxBytes);
    const body = deserializedTx[0];
    const signatures = deserializedTx[1];
    return {
        blockchainRID: body[0],
        operations: body[1].map(operation => ({opName: operation[0], args: operation[1]})),
        signers: body[2],
        signatures
    };
};

exports.checkGTXSignatures = function(txHash, gtx) {
    if(gtx.signatures.length < gtx.signers.length) throw Error("Not enough signatures");
    for(const i in gtx.signers) {
        const signValid = util.checkDigestSignature(txHash, gtx.signers[i], gtx.signatures[i]);
        if(!signValid) return signValid;
    }
    return true;
};


// DEPRECATED
exports.encodeValue = gtv.encodeGtv;
exports.decodeValue = gtv.decodeGtv;
