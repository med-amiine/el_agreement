"use strict"

var PathLeafElement = require('./path').PathLeafElement

const HASH_PREFIX_NODE = 0
const HASH_PREFIX_LEAF = 1
const HASH_PREFIX_NODE_ARRAY = 7
const HASH_PREFIX_NODE_DICT = 8

/**
 * 
 */
function BinaryTreeElement() {
  this.pathElem = null
}
BinaryTreeElement.prototype.isPath = function() {
  return this.pathElem != null
}
BinaryTreeElement.prototype.isPathLeaf = function() {
  if (this.pathElem == null) {
    return false
  }
  if (this.pathElem instanceof PathLeafElement) {
    return true
  } else {
    return false
  }
}
BinaryTreeElement.prototype.setPathElement = function(pathElem) {
  this.pathElem = pathElem
}
BinaryTreeElement.prototype.getPrefixByte = function() {
  return HASH_PREFIX_NODE;
}

/**
 * 
 * @param {BinaryTreeElement} left 
 * @param {BinaryTreeElement} right 
 */
function Node(left, right) {
  this.left = left;
  this.right = right;  
}

Node.prototype = Object.create(BinaryTreeElement.prototype)
Node.prototype.constructor = Node

Node.prototype.getPrefixByte = function() {
  return HASH_PREFIX_NODE;
}

/**
 * 
 * @param {BinaryTreeElement} left 
 * @param {BinaryTreeElement} right 
 * @param {*} content 
 * @param {PathSet} pathElem 
 */
function SubTreeRootNode(left, right, content, pathElem) {
  Node.call(this, left, right)
  this.content = content
  BinaryTreeElement.prototype.setPathElement.call(this, pathElem)
}

SubTreeRootNode.prototype = Object.create(Node.prototype)
SubTreeRootNode.prototype.constructor = SubTreeRootNode

/**
 * 
 * @param {*} content 
 * @param {PathElement} pathElem 
 */
function Leaf(content, pathElem=null) {
  this.content = content
  if (pathElem != null) {
    if (pathElem instanceof PathLeafElement) {
      BinaryTreeElement.prototype.setPathElement.call(this, pathElem)
    } else {
      throw new Error("The path and object structure does not match! We are at a leaf, but the path expects a sub structure.")
    }
  }
}

Leaf.prototype = Object.create(BinaryTreeElement.prototype)
Leaf.prototype.constructor = Leaf

Leaf.prototype.getPrefixByte = function() {
  return HASH_PREFIX_LEAF
}

function EmptyLeaf() {}
EmptyLeaf.prototype = Object.create(BinaryTreeElement.prototype)
EmptyLeaf.prototype.constructor = EmptyLeaf

/**
 * Wrapper class for the root object.
 * @param {BinaryTreeElement} root
 */
function BinaryTree(root) {
  this.root = root
}

BinaryTree.prototype.maxLevel = function() {
  return this.maxLevelInternal(this.root)
}

BinaryTree.prototype.maxLevelInternal = function(node) {
  if (node instanceof EmptyLeaf) {
    return 0
  } else if (node instanceof Leaf) {
    return 1
  } else if (node instanceof Node) {
    return Math.max(this.maxLevelInternal(node.left), this.maxLevelInternal(node.right)) + 1
  } else {
    throw new Error("What is this type? " + typeof node)
  }
}

/**
 * Represents the top of a sub tree generated by a [Array]
 * 
 * @param {*} left 
 * @param {*} right 
 * @param {*} content
 * @param {*} size 
 * @param {PathElement} pathElem 
 */
function ArrayHeadNode(left, right, content, size, pathElem=null) {
  SubTreeRootNode.call(this, left, right, content, pathElem)
  this.size = size
}

ArrayHeadNode.prototype = Object.create(SubTreeRootNode.prototype)
ArrayHeadNode.prototype.constructor = ArrayHeadNode
ArrayHeadNode.prototype.getPrefixByte = function() {
  return HASH_PREFIX_NODE_ARRAY
}

/**
 * Represents the top a sub tree generated by a [Dictionary]
 * @param {*} left 
 * @param {*} right 
 * @param {*} content 
 * @param {*} size 
 * @param {PathElement} pathElem 
 */
function DictHeadNode(left, right, content, size, pathElem=null) {
  SubTreeRootNode.call(this, left, right, content, pathElem)
  this.size = size
}

DictHeadNode.prototype = Object.create(SubTreeRootNode.prototype)
DictHeadNode.prototype.constructor = DictHeadNode
DictHeadNode.prototype.getPrefixByte = function() {
  return HASH_PREFIX_NODE_DICT
}

module.exports = {HASH_PREFIX_NODE, HASH_PREFIX_LEAF, HASH_PREFIX_NODE_ARRAY, HASH_PREFIX_NODE_DICT, 
  Node, Leaf, EmptyLeaf, SubTreeRootNode, BinaryTreeElement, BinaryTree, ArrayHeadNode, DictHeadNode}